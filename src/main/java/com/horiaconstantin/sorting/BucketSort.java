package com.horiaconstantin.sorting;

import java.util.Set;
import java.util.TreeSet;

/**
 * Bucket sort assumes that the input of n elems arrat is generated by a random
 * process that distributes elements uniformly and independently over the
 * interval[0; 1) Bucket sort divides the interval[0; 1) into n equal-sized
 * subintervals, or buckets, and then distributes then input numbers into the
 * buckets. To produce the output, we simply sort the numbers (insertion sort)
 * in each bucket and then go through the buckets in order, listing the elements
 * in each.
 * 
 * @author Horia Constantin
 * 
 */
public class BucketSort {

	public double[] sort(double maxValue, int buckets, double[] a) {
		double[] bucketLimits = new double[buckets];
		Set<Double>[] list = new Set[buckets];

		for (int i = 0; i < buckets; i++) {
			bucketLimits[i] = maxValue / buckets * i;
		}
		for (int i = 0; i < a.length; i++) {
			for (int j = 0; j < buckets; j++) {
				if (j == buckets - 1 && bucketLimits[j] <= a[i]) {
					if (list[j] == null)
						list[j] = new TreeSet<>();
					list[j].add(a[i]);
					break;
				}
				if (bucketLimits[j] <= a[i] && a[i] < bucketLimits[j + 1]) {
					if (list[j] == null)
						list[j] = new TreeSet<>();
					list[j].add(a[i]);
					break;
				}
			}
		}
		double[] result = new double[a.length];
		int counter = 0;
		for (Set<Double> set : list) {
			if (set == null) {
				continue;
			}
			for (Double value : set) {
				if (value != null) {
					result[counter] = value;
					counter++;
				}
			}
		}

		return result;
	}

}
